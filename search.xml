<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[【Java】 之 「demo版租车系统」]]></title>
      <url>http://yoursite.com/2017/02/10/%E3%80%90Java%E3%80%91%20%E4%B9%8B%20%E3%80%8Cdemo%E7%89%88%E7%A7%9F%E8%BD%A6%E7%B3%BB%E7%BB%9F%E3%80%8D/</url>
      <content type="html"><![CDATA[<p><strong>前言：</strong><br>最近重新学了一遍java, 两年没碰过，显得很生疏。从最基本的语法开始，到封装/多态/继承的概念,以及抽象类/接口都过了一遍。</p>
<p>写点代码练练手，撸了一个很初级的租车系统，仅为重温以上所提内容。</p>
<p><strong>实现如下：</strong><br><a id="more"></a></p>
<p>父类Car</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">// 定义抽象类Car</span><br><span class="line">public abstract class Car &#123;</span><br><span class="line">	//车的种类</span><br><span class="line">	public String carType;</span><br><span class="line">	//租车的价格</span><br><span class="line">	public int rentPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>载人接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">//定义载人这个行为的接口</span><br><span class="line">public interface IPassengerCapacity &#123;</span><br><span class="line">	//默认会赋成抽象方法(不能有方法体)</span><br><span class="line">	public int getPassengerCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>载货接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">//定义载货这个行为的接口</span><br><span class="line">public interface IGoodsCapacity &#123;</span><br><span class="line">	public int getGoodsCapacity(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>载人车类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">// 定义只可以载人的汽车，实现了IPassengerCapacity接口</span><br><span class="line">public class PassengerCar extends Car implements IPassengerCapacity &#123;</span><br><span class="line">	//定义私有变量表示载客量</span><br><span class="line">	private int passengerCapacity;</span><br><span class="line">	//定义带参数的构造方法，以初始化新车</span><br><span class="line">	PassengerCar(String type, int rentPrice, int passengerCapacity)&#123;</span><br><span class="line">		// carType和rentPrice变量继承至抽象类car</span><br><span class="line">		this.carType = type; </span><br><span class="line">		this.rentPrice = rentPrice;</span><br><span class="line">		//passengerCapacity为PassengerCar新定义的私有变量</span><br><span class="line">		this.passengerCapacity = passengerCapacity;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	//覆写了接口中的抽象方法</span><br><span class="line">	public int getPassengerCapacity() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return passengerCapacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>卡车类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line"></span><br><span class="line">public class Trunk extends Car implements IGoodsCapacity &#123;</span><br><span class="line">	private int goodCapacity;</span><br><span class="line">	Trunk(String type, int rentPrice, int goodCapacity)&#123;</span><br><span class="line">		this.carType = type;</span><br><span class="line">		this.rentPrice = rentPrice;</span><br><span class="line">		this.goodCapacity = goodCapacity;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int getGoodsCapacity() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return goodCapacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>皮卡类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">// 定义皮卡类，既可以载人又可以载客，故同时实现了两个接口</span><br><span class="line">public class Pickup extends Car implements IGoodsCapacity, IPassengerCapacity &#123;</span><br><span class="line">	private int goodCapacity;</span><br><span class="line">	private int passengerCapacity;</span><br><span class="line">	public Pickup(String type, int rentPrice, int goodCapacity, int passengerCapacity) &#123;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">		this.carType = type;</span><br><span class="line">		this.rentPrice = rentPrice;</span><br><span class="line">		this.goodCapacity = goodCapacity;</span><br><span class="line">		this.passengerCapacity = passengerCapacity;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int getPassengerCapacity() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return passengerCapacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int getGoodsCapacity() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return goodCapacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rentCarSystem;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Initial</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//定义一个数组，存储初始化过的车辆</span></span><br><span class="line">		Car[] CarsforRent= &#123;<span class="keyword">new</span> PassengerCar(<span class="string">"宝马Z4"</span>, <span class="number">800</span>, <span class="number">2</span>),<span class="keyword">new</span> PassengerCar(<span class="string">"金龙大巴"</span>, <span class="number">600</span>, <span class="number">30</span>),<span class="keyword">new</span> Trunk(<span class="string">"拖拉机"</span>, <span class="number">200</span>, <span class="number">10</span>),<span class="keyword">new</span> Pickup(<span class="string">"皮卡"</span>, <span class="number">300</span>, <span class="number">5</span>, <span class="number">4</span>)&#125;;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"*******欢迎来到租车系统******"</span>);</span><br><span class="line">		System.out.println(<span class="string">"hi,你是否要租车? Y/N"</span>);</span><br><span class="line">		<span class="comment">//仅为一个demo. 所有输入都不做非法输入处理</span></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		String isRent = input.next().toUpperCase();</span><br><span class="line">		<span class="keyword">if</span>(isRent.equals(<span class="string">"Y"</span>))&#123;</span><br><span class="line">			System.out.println(<span class="string">"以下是您可选择的租车详情"</span>);</span><br><span class="line">			System.out.println(<span class="string">"序号\t类型\t日租金\t容量"</span>);</span><br><span class="line">			<span class="keyword">int</span> carID = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(Car newcar : CarsforRent)&#123;</span><br><span class="line">				<span class="keyword">if</span>(newcar <span class="keyword">instanceof</span> PassengerCar)&#123;</span><br><span class="line">					<span class="comment">//注意在拿到乘客数量的时候要做类型转换</span></span><br><span class="line">					System.out.println(carID +<span class="string">".\t"</span> +newcar.carType+ <span class="string">"\t"</span> +newcar.rentPrice+ <span class="string">"\t"</span> +<span class="string">"载人："</span>+((PassengerCar)newcar).getPassengerCapacity()+ <span class="string">"人"</span> );</span><br><span class="line">					carID++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(newcar <span class="keyword">instanceof</span> Trunk)&#123;</span><br><span class="line">					System.out.println(carID +<span class="string">".\t"</span> +newcar.carType+ <span class="string">"\t"</span> +newcar.rentPrice+ <span class="string">"\t"</span> +<span class="string">"载货："</span>+((Trunk)newcar).getGoodsCapacity()+ <span class="string">"吨"</span> );</span><br><span class="line">					carID++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(newcar <span class="keyword">instanceof</span> Pickup)&#123;</span><br><span class="line">					System.out.println(carID +<span class="string">".\t"</span> +newcar.carType+ <span class="string">"\t"</span> +newcar.rentPrice+ <span class="string">"\t"</span> +<span class="string">"载人："</span>+((Pickup)newcar).getPassengerCapacity()+ <span class="string">"人；"</span> +<span class="string">"载货："</span>+((Pickup)newcar).getGoodsCapacity()+ <span class="string">"吨"</span> );</span><br><span class="line">					carID++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"请输入您要租车的数量(1-4辆):"</span>);</span><br><span class="line">			<span class="keyword">int</span> carQuantity = input.nextInt();</span><br><span class="line">			<span class="comment">//新建一个长度为租车数量的数组来储存用户选中的车的序号</span></span><br><span class="line">			<span class="keyword">int</span>[] selectedCarsIndex = <span class="keyword">new</span> <span class="keyword">int</span>[carQuantity];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; carQuantity; i++)&#123;</span><br><span class="line">				System.out.println(<span class="string">"请输入欲租第"</span>+(i+<span class="number">1</span>)+<span class="string">"辆车的序号(1-4)："</span>);</span><br><span class="line">				selectedCarsIndex[i] = input.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"请输入您要用车的天数:"</span>);</span><br><span class="line">			<span class="keyword">int</span> useDays=input.nextInt(); </span><br><span class="line">			<span class="keyword">int</span> passengerSum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> goodSum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> moneySum=<span class="number">0</span>;</span><br><span class="line">			System.out.println(<span class="string">"***预定完成，您的订单如下： \n可载人的车辆有： "</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; carQuantity; i++)&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>] <span class="keyword">instanceof</span> PassengerCar )&#123;</span><br><span class="line">					passengerSum += ((PassengerCar)CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>]).getPassengerCapacity();</span><br><span class="line">					System.out.print(CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>].carType+<span class="string">":"</span>+((PassengerCar)CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>]).getPassengerCapacity() +<span class="string">"人;"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>] <span class="keyword">instanceof</span> Pickup)&#123;</span><br><span class="line">					passengerSum += ((Pickup)CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>]).getPassengerCapacity();</span><br><span class="line">					System.out.print(CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>].carType+<span class="string">":"</span>+((Pickup)CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>]).getPassengerCapacity() +<span class="string">"人;"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				moneySum += CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>].rentPrice * useDays;</span><br><span class="line">			&#125;</span><br><span class="line">			input.close();</span><br><span class="line">			System.out.println(<span class="string">"\n--总共可搭乘："</span>+passengerSum+<span class="string">"人"</span>);</span><br><span class="line">			<span class="comment">//计算可搭乘货物量的代码类似，这里就略去</span></span><br><span class="line">			System.out.println(<span class="string">"--总共花费："</span>+moneySum+<span class="string">" CNY"</span>);</span><br><span class="line">			System.out.println(<span class="string">"*********租车结束，欢迎再次光临！*******"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"*********谢谢来访，欢迎再次光临！*******"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[LeetCode] - 两道3Sum题目]]></title>
      <url>http://yoursite.com/2017/01/31/%E3%80%90LeetCode%E3%80%91%20-%20%E4%B8%A4%E9%81%933Sum%E9%A2%98%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>一道实现起来比较简单的题，但是被细节坑了很久….</p>
<p>原题如下：</p>
<blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note: The solution set must not contain duplicate triplets.</p>
<p>For example, given array S = [-1, 0, 1, 2, -1, -4],</p>
<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]<br><a id="more"></a></p>
</blockquote>
<p>题目意思就是找出三数相加为0的数，组合成新的数组返回。<br>做leetcode第一题就是2sum（找出两数相加为0的数并返回索引），这题算是加强版吧。</p>
<p><strong>解题过程：</strong><br>The solution uses the sliding window/two pointers algorithm. Let us try to solve the simpler problem first:<br>Given a sorted array, find all pairs of elements a,b such that a+b=c, a given value</p>
<p>Now, suppose that we have found a solution ar[i],ar[j]. That is, ar[i]+ar[j]=c. If there is some other solution with ar[i’] (That is, ar[i’]+ar[j’]=c), we will have j’≤j. Using this observation the problem can be solved by the following function in O(N):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void findpairs(int ar[],int N,int c)</span><br><span class="line">&#123;</span><br><span class="line">  for(int i=0,j=N-1;i&lt;j;)</span><br><span class="line">  &#123;</span><br><span class="line">    //Move the j-pointer to the left till the sum &lt;=c</span><br><span class="line">    if(ar[i]+ar[j]&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">      j--;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ar[i]+ar[j]==c)printf(&quot;%d %d\n&quot;,ar[i],ar[j]);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if there are duplicate entries in the array, there could be duplicate entries in the output too. This can be easily taken care of by a simple modification. We ensure that we process the i-values corresponding to a given ar[i] only once:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void findpairs(int ar[],int N,int c)</span><br><span class="line">&#123;</span><br><span class="line">  for(int i=0,j=N-1;i&lt;j;)</span><br><span class="line">  &#123;</span><br><span class="line">    if(ar[i]+ar[j]&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">      j--;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ar[i]+ar[j]==c)printf(&quot;%d %d\n&quot;,ar[i],ar[j]);</span><br><span class="line">    //Increment i till ar[i] is different from current value</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;while((i&lt;j)&amp;&amp;(ar[i]==ar[i-1]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now to get back to the original problem. We will sort the array first to utilise the two pointers algorithm. Let us first fix the smallest element in the triplet ar[i]. Now we need to find other elements in the array such that their sum is -ar[i]. Using the same trick to avoid repetitions, here is the final solution:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findtriplets</span><span class="params">(<span class="keyword">int</span> ar[],<span class="keyword">int</span> N)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = [];</span><br><span class="line">  <span class="comment">//First sort the array since the method works only for sorted arrays</span></span><br><span class="line">  sort(ar,ar+N);</span><br><span class="line">  <span class="comment">//Loop over first element of triplet</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//Discard repetitions for first element</span></span><br><span class="line">    <span class="keyword">if</span>((i&gt;=<span class="number">0</span>)&amp;&amp;(ar[i]==ar[i<span class="number">-1</span>]))<span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//This loop is essentially the same as findpairs() above.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>,k=N<span class="number">-1</span>;j&lt;k;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(ar[i]+ar[j]+ar[k]&gt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(ar[i]+ar[j]+ar[k]==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         result.push([nums[i],nums[j],nums[k]]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;<span class="keyword">while</span>((j&lt;k)&amp;&amp;(ar[j]==ar[j<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sorting takes O(N log N) time whereas the repeated application of the two pointers algorithm takes O(N²) time.</p>
<hr>
<p>另一题是第一题的变体，题目叫‘3Sum Closest’。实现起来更简单，原题如下：</p>
<blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.<br>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp, sum, tsum;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">    <span class="keyword">var</span> sorted = nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; sorted.length; i++)&#123;</span><br><span class="line">       <span class="keyword">var</span> start = i+<span class="number">1</span>, end= sorted.length<span class="number">-1</span>;</span><br><span class="line">       <span class="comment">// 这里用到了二分法</span></span><br><span class="line">       <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            tsum = sorted[i] + sorted[start] + sorted[end];</span><br><span class="line">            temp = <span class="built_in">Math</span>.abs(tsum - target);</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; key)&#123;</span><br><span class="line">                key = temp;</span><br><span class="line">                sum = tsum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tsum &lt; target)&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  [LeetCode] - 不使用加减运算符，求两数之和]]></title>
      <url>http://yoursite.com/2017/01/15/%E3%80%90LeetCode%E3%80%91-%20%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E6%B1%82%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<p>今天刷leetCode看到一道题蛮有意思的，做个记录。</p>
<p>原题如下：</p>
<blockquote>
<p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br>Given a = 1 and b = 2, return 3.<br><a id="more"></a><br>题目意思很简单，如标题所述，要想不用加减号(普通运算符)求和，自然联想到位运算，关于位运算相关知识可参考：<a href="http://blog.csdn.net/21aspnet/article/details/7387373" target="_blank" rel="external">http://blog.csdn.net/21aspnet/article/details/7387373</a></p>
</blockquote>
<p>回顾一下二进制加法计算过程：在做某位加法时，单看这一位，若两数相同，则得出0；若不同，则得出1，这不就是位运算当中的异或^嘛！</p>
<p>知道了这个，怎么处理进位呢？接着看二进制加法，进位特点是：都是往高处（向左）进一位，且只有两个加数都是1时，才会产生进位，这不就是按位与&amp;嘛。将按位与得到的数字向左移动一位，把其当成一个新数字，用新数字与上一步逐位异或得到的数字相加，重复这个过程。实际上就是拆分了每一步进位过程，每一次循环即为一次进位，加到最后，肯定不产生进位了。 即当按位与的结果为0的时候，证明已经没有进位，循环终止，此时得到的sum即为两数的和。</p>
<p>举个栗子:<br>设有a = 3，b = 6。</p>
<p>a　　　　0011</p>
<p>b　　　　0110</p>
<p>不进位和(按位异或) 0101  = 5</p>
<p>进位（按位与）  0010  = 2</p>
<p><strong>因此 a + b就变成了5 + （2 &lt;&lt; 1）</strong></p>
<p>然后有</p>
<p>5　　　　0101</p>
<p>2&lt;&lt;1 　　0100</p>
<p>不进位和 0001  = 1</p>
<p>进位          0100  = 4</p>
<p><strong>因此 a + b就变成了1 + （4 &lt;&lt; 1）</strong></p>
<p>然后有</p>
<p>1　　　　0001</p>
<p>4&lt;&lt;1 　　1000</p>
<p>不进位和 1001  = 9</p>
<p>进位          0000  = 0</p>
<p><strong>当进位为0时，不进位和为9，即a + b和为9。</strong></p>
<p>实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;number&#125; a</span><br><span class="line"> * @param &#123;number&#125; b</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jinwei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        jinwei = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = sum;</span><br><span class="line">        b = jinwei;</span><br><span class="line">    &#125;<span class="keyword">while</span>(jinwei != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【js游戏】 之 「五子棋」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90js%E6%B8%B8%E6%88%8F%E3%80%91%E4%B9%8B%E3%80%8C%E4%BA%94%E5%AD%90%E6%A3%8B%E3%80%8D/</url>
      <content type="html"><![CDATA[<p>用js撸了几个小游戏，比如五子棋（人机对战），有空写个详细的实现过程，不过代码注释已经写得比较详细了，直接审查元素就能看到。</p>
<hr>
<p>这里直接上五子棋游戏传送门：<br><a href="http://www.kangkai.science/chess.html" target="_blank" rel="external">http://www.kangkai.science/chess.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「快速排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>快排简而言之就三步：</p>
<ol>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<a id="more"></a>
</li>
</ol>
<h3 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h3><ol>
<li>时间复杂度：O（nlogn）</li>
<li>空间复杂度：O（N）</li>
<li>排序性质：主要操作在源数据存储区进行，属于内部排序。不稳定排序。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里参照了阮一峰老师的JS 实现</p>
<p>定义一个quickSort函数，它的参数是一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，检查数组的元素个数，如果小于等于1，就返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) ;</span><br><span class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">　　<span class="keyword">var</span> left = [];</span><br><span class="line">　　<span class="keyword">var</span> right = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于基准的元素放入右边的子集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) ;</span><br><span class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">　　<span class="keyword">var</span> left = [];</span><br><span class="line">　　<span class="keyword">var</span> right = [];</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后，使用递归不断重复这个过程，就可以得到排序后的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">　　<span class="keyword">var</span> left = [];</span><br><span class="line">　　<span class="keyword">var</span> right = [];</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>C语言版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key; <span class="comment">//key即为基准</span></span><br><span class="line">    key = arr[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;high &amp;&amp; arr[high] &gt;= key)</span><br><span class="line">            high--;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        <span class="comment">// 注意是先赋值后移动</span></span><br><span class="line">            arr[low++] = arr[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt;high &amp;&amp; arr[low] &lt;= key)</span><br><span class="line">            low++;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">            arr[high--] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (start&lt;end)&#123;</span><br><span class="line">        pos = partition(arr, start, end);</span><br><span class="line">        quick_sort(arr,start,pos<span class="number">-1</span>);</span><br><span class="line">        quick_sort(arr,pos+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> arr[N]=&#123;<span class="number">32</span>,<span class="number">12</span>,<span class="number">7</span>, <span class="number">78</span>, <span class="number">23</span>,<span class="number">45</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序前 \n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,arr[i]);</span><br><span class="line">    quick_sort(arr,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n 排序后 \n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「冒泡排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>冒泡重复地走访要排序的数列，一次比较最底下两个元素（即数列最前面两个元素），如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</p>
<p>每一轮交换都换产生余下数组最大的数，并冒到顶部。<br><a id="more"></a></p>
<h3 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h3><ol>
<li>时间复杂度：O(N^2)，进行N-1轮操作，每次进行n-1次交换</li>
<li>空间复杂度：O(N)</li>
<li>排序性质：内部排序，稳定排序</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>先列出一种效率较低的方法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">int</span> i,j,mid;</span><br><span class="line">      <span class="keyword">int</span> length = <span class="number">10</span>;</span><br><span class="line">      <span class="comment">//开始外圈循环</span></span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">          <span class="comment">//外圈循环到i时，说明该数组的后i-1个数已经排好序并且是最大值</span></span><br><span class="line">          <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">9</span>-i;j++) </span><br><span class="line">          &#123;</span><br><span class="line">               <span class="keyword">if</span>(a[j]&gt;=a[j+<span class="number">1</span>])</span><br><span class="line">               &#123;</span><br><span class="line">                    mid = a[j];</span><br><span class="line">                    a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                    a[j+<span class="number">1</span>] = mid;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d   "</span>,a[i]);</span><br><span class="line">      system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个冒泡排序算法中有一个缺陷，如果数组是 2 1 3 4 5 6 ，那么在第一次外圈结束后，该数组就已经完成排序，但是程序还是会继续循环下去，做很多无用的比较，但是根本不会出现数的位置的交换。++所以我们需要考虑一下冒泡排序的结束条件++。</p>
<p>下面给出一个定义：如果冒泡排序在一次外圈的内圈循环中没有出现数的位置的交换，那么该数组排序完成，不需要向下进行。解释一下这个定义，内圈的循环是从0~length-i-1的，不出现交换说明在这个范围内后一个数都大于前一个数，而在length-i-1至lenth的范围中，本来就是符合条件的，所以定义成立。<br>所以我们添加一个flag标志，观察在每次外圈时是否出现数值的交换。<br>下面给出改进算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">int</span> i,j,mid;</span><br><span class="line">      <span class="keyword">int</span> length = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> flag = <span class="number">1</span>;   <span class="comment">//标识符</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span> &amp;&amp; flag;i++)   <span class="comment">//注意判定条件</span></span><br><span class="line">          <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">9</span>-i;j++)</span><br><span class="line">          &#123;</span><br><span class="line">               flag=<span class="number">0</span>;        <span class="comment">//每次外圈时初始化</span></span><br><span class="line">               <span class="keyword">if</span>(a[j] &gt;= a[j+<span class="number">1</span>])</span><br><span class="line">               &#123;</span><br><span class="line">                    mid = a[j];</span><br><span class="line">                    a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                    a[j+<span class="number">1</span>] = mid;</span><br><span class="line">                    flag=<span class="number">1</span>;      <span class="comment">//如果有交换，那么可以进入下一圈循环</span></span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d   "</span>,a[i]);</span><br><span class="line">      system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「归并排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。不断将已有序的子序列合并，最后得到一个统一的有序序列。</p>
<p>归并操作(从小到大）的工作原理如下：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并将该指针移动到下一位置（另一指向较大元素的指针位置不变）。</li>
<li>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾<a id="more"></a>
<h3 id="相关性质总结"><a href="#相关性质总结" class="headerlink" title="相关性质总结"></a>相关性质总结</h3></li>
<li>时间复杂度：O(n log n) ；</li>
<li>空间复杂度：O（N）；</li>
<li>排序性质：稳定</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> sourceArr[],<span class="keyword">int</span> tempArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> midIndex, <span class="keyword">int</span> endIndex)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="comment">//i 和 j分别指向两个有序数组的起始位置;k是排序后新数组的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = startIndex, j=midIndex+<span class="number">1</span>, k = startIndex;</span><br><span class="line">    <span class="keyword">while</span>(i!=midIndex+<span class="number">1</span> &amp;&amp; j!=endIndex+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">        <span class="comment">//tempArr为二路归并后的新数组</span></span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩下所有的元素都移到tempArr数组</span></span><br><span class="line">    <span class="keyword">while</span>(i != midIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j != endIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> sourceArr[], <span class="keyword">int</span> tempArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        midIndex = (startIndex + endIndex) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">        <span class="comment">//最后将两个有序数组合并</span></span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i, b[<span class="number">8</span>];</span><br><span class="line">    MergeSort(a, b, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「插入排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<p><strong>前言：</strong>在【排序算法】板块中，我将纳入几种主流的排序算法学习笔记，代码以C为主，可能还会涉及我较熟悉的JavaScript</p>
<p><em>内容很基础，作为今后快速查阅的资料</em></p>
<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>插入排序是排序算法的一种，它不改变原有的序列（数组），而是创建一个新的序列，在新序列上进行操作。</p>
<p>基本思想是，将元素逐个添加到已经排序好的数组中去，同时要求，插入的元素必须在正确的位置，这样原来排序好的数组是仍然有序的。第i轮排序时，在前i个元素的子数组中插入第i+1个元素。直到所有元素都加入排序好数组。<strong>类似于打扑克牌的抓拍过程，每次抓一张新牌都将其插入到手里已经排好序的牌当中。</strong><br><a id="more"></a></p>
<h3 id="相关性质总结"><a href="#相关性质总结" class="headerlink" title="相关性质总结"></a>相关性质总结</h3><ol>
<li>时间复杂度：O(N平方),无论何种情况，要插入N个数首先必然要进行N轮操作，最坏情况下再交换N次，即N*N;</li>
<li>空间复杂度：O（N），即存储N个数字的空间</li>
<li>排序性质：插入排序是一种稳定的排序算法，不会改变原有序列中相同数字的顺序；均在内存中进行，为内部排序。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//插入排序实现,这里按从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span><span class="comment">//n为数组a的元素个数</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//进行N-1轮插入过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先找到元素a[i]需要插入的位置</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( (a[j]&lt;a[i]) &amp;&amp; (j&lt;i) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里a[j]实际为新构造的排序后的数组，j即为插入位置</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将元素插入到正确的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i != j)  <span class="comment">//如果i==j，说明a[i]刚好在正确的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &gt; j; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k] = a[k<span class="number">-1</span>];<span class="comment">//将插入位置以后的数都后移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = temp;<span class="comment">//将数字插入位置j</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[N] = &#123;<span class="number">89</span>, <span class="number">38</span>, <span class="number">11</span>, <span class="number">78</span>, <span class="number">96</span>, <span class="number">44</span>, <span class="number">19</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    insert_sort(num, N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, num[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客上线小记]]></title>
      <url>http://yoursite.com/2016/05/22/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><del>写在前面的屁话</del></p>
<pre><code>好久没有碰工程项目啦！自从大二在工作室接外包做了几个项目之后，除了课程相关的代码，
就再也没有实际的写过东西了，这段时间趁着导师内边事情不多，把自己的博客搭起来，也算练练手吧。
</code></pre><h3 id="为什么要搭建个人博客"><a href="#为什么要搭建个人博客" class="headerlink" title="为什么要搭建个人博客"></a>为什么要搭建个人博客</h3><ul>
<li><p><strong>记录</strong>：自从高中毕业之后，很少用心写作了（说的好像高中作文也是用心写的一样）。决心利用博客重新开始写作，主要用来记录自己的技术成长路线，偶尔也会用来表达生活感悟。</p>
</li>
<li><p><strong>分享</strong>：过去我看过很多的个人博客（几乎是程序猿标配了），却一直没有抽时间搭建属于自己的博客。现在觉得还是得把它建起来，主要为自己记录，最好也能为他人做微不足道的分享。其实一直有想法找个地方写写东西，新浪博客、CSDN、微信公众号都有尝试，还有幸作为知乎专栏内测用户，但是都没有坚持下去，希望这里能够记录更多的内容吧。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="怎么搭建个人博客"><a href="#怎么搭建个人博客" class="headerlink" title="怎么搭建个人博客"></a>怎么搭建个人博客</h3><p>阮一峰老师说过，博客的搭建会经历三个阶段:</p>
<blockquote>
<p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</p>
<p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p>
<p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<p>  这里我选择了第二种方式，但是抱着急功近利的心态，连最初计划的后端Thinkphp + 前端bootstrap框架的方法都放弃了，直接用了github的开源框架hexo…（ 羞耻脸</p>
<p>  全站自己写的东西不多，用了无数轮子，主要功夫都花在配环境和「移花接木」上了。</p>
<hr>
<p>  <em>2016.05.22晚</em></p>
<p> 买了自己的独立域名，算是正式上线的开始吧，<br> 原本是想买最直接的”www.kangkai.com”,即姓名全拼+com后缀，无奈也不出意外地被注册了，连cn,org等传统顶级域名都被注册了….</p>
<p> 只好另辟蹊径，发现了.science后缀觉得挺有big的。。就果断买了下来（到2018年都是我的哈哈哈）</p>
<p>  之前建设过程中迭代过几个版本，这里就不一一详细记录了，今后有功能上的变化都会把过程和技术难点以博客形式记录。上一版中增加了文章末尾的微信打赏二维码和RSS订阅功能，优化了评论框（多说接口）的性能和UI设计，不存在技术上问题。</p>
<p>  差不多了，我去看电影了，bye~</p>
<p>  <strong>喜欢我的博客或者发现bug欢迎留言！</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dijkstra's algorithm]]></title>
      <url>http://yoursite.com/2016/05/19/Dijkstra-s-algorithm/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Dijkstra’s algorithm</strong></p>
<h2 id="Dijkstra’s-algorithm-is-an-algorithm-for-finding-the-shortest-paths-between-nodes-in-a-graph-which-may-represent-for-example-road-networks-It-was-conceived-by-computer-scientist-Edsger-W-Dijkstra-in-1956-and-published-three-years-later"><a href="#Dijkstra’s-algorithm-is-an-algorithm-for-finding-the-shortest-paths-between-nodes-in-a-graph-which-may-represent-for-example-road-networks-It-was-conceived-by-computer-scientist-Edsger-W-Dijkstra-in-1956-and-published-three-years-later" class="headerlink" title="Dijkstra’s algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later."></a>Dijkstra’s algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</h2><p>戴克斯特拉算法（英语：Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。<br><a id="more"></a></p>
<pre><code>   function Dijkstra(G, w, s)
      for each vertex v in V[G]                        // 初始化
            d[v] := infinity                                 // 將各點的已知最短距離先設成無窮大
            previous[v] := undefined                         // 各点的已知最短路径上的前趋都未知
     d[s] := 0                                              // 因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0
      S := empty set
      Q := set of all vertices
      while Q is not an empty set                      // Dijkstra演算法主體
            u := Extract_Min(Q)
10           S.append(u)
11           for each edge outgoing from u as (u,v)
12                  if d[v] &gt; d[u] + w(u,v)             // 拓展边（u,v）。w(u,v)为从u到v的路径长度。
13                        d[v] := d[u] + w(u,v)               // 更新路径长度到更小的那个和值。
14                        previous[v] := u                    // 紀錄前趨頂點
</code></pre><p>该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t 的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。</p>
<p>最初的戴克斯特拉算法不采用最小优先级队列，时间复杂度是O(|V|^2)(其中|V|为图的顶点个数)。通过斐波那契堆实现的迪科斯彻算法时间复杂度是O(|E|+|V|\log|V|) (其中|E|是边数) （Fredman &amp; Tarjan 1984）。对于不含负权的有向图，这是目前已知的最快的单源最短路径算法。</p>
<p>如果我们只对在 s 和 t 之间查找一条最短路径的话，我们可以在第9行添加条件如果满足 u = t 的话终止程序。</p>
<p>通过推导可知，为了记录最佳路径的轨迹，我们只需记录该路径上每个点的前趋，即可通过迭代来回溯出 s 到 t 的最短路径（当然，使用后继节点来存储亦可。但那需要修改代码）：</p>
<pre><code>1 s := empty sequence 
2 u := t
3 while defined u                                        
4       insert u to the beginning of S
5       u := previous[u]      //previous数组即为上文中的p
</code></pre>]]></content>
    </entry>
    
  
  
</search>
