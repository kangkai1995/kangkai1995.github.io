<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[【js游戏】 之 「五子棋」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90js%E6%B8%B8%E6%88%8F%E3%80%91%E4%B9%8B%E3%80%8C%E4%BA%94%E5%AD%90%E6%A3%8B%E3%80%8D/</url>
      <content type="html"><![CDATA[<p>用js撸了几个小游戏，比如五子棋（人机对战），有空写个详细的实现过程，不过代码注释已经写得比较详细了，直接审查元素就能看到。</p>
<hr>
<p>这里直接上五子棋游戏传送门：<br><a href="http://www.kangkai.science/chess.html" target="_blank" rel="external">http://www.kangkai.science/chess.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「快速排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>快排简而言之就三步：</p>
<ol>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<a id="more"></a>
</li>
</ol>
<h3 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h3><ol>
<li>时间复杂度：O（nlogn）</li>
<li>空间复杂度：O（N）</li>
<li>排序性质：主要操作在源数据存储区进行，属于内部排序。不稳定排序。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里参照了阮一峰老师的JS 实现</p>
<p>定义一个quickSort函数，它的参数是一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var quickSort = function(arr) &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，检查数组的元素个数，如果小于等于1，就返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var quickSort = function(arr) &#123;</span><br><span class="line">　　if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var quickSort = function(arr) &#123;</span><br><span class="line">　　if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line">　　var pivotIndex = Math.floor(arr.length / 2) ;</span><br><span class="line">　　var pivot = arr.splice(pivotIndex, 1)[0];</span><br><span class="line">　　var left = [];</span><br><span class="line">　　var right = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于基准的元素放入右边的子集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var quickSort = function(arr) &#123;</span><br><span class="line">　　if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line">　　var pivotIndex = Math.floor(arr.length / 2) ;</span><br><span class="line">　　var pivot = arr.splice(pivotIndex, 1)[0];</span><br><span class="line">　　var left = [];</span><br><span class="line">　　var right = [];</span><br><span class="line">　　for (var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　if (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; else &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后，使用递归不断重复这个过程，就可以得到排序后的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var quickSort = function(arr) &#123;</span><br><span class="line">　　if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line">　　var pivotIndex = Math.floor(arr.length / 2);</span><br><span class="line">　　var pivot = arr.splice(pivotIndex, 1)[0];</span><br><span class="line">　　var left = [];</span><br><span class="line">　　var right = [];</span><br><span class="line">　　for (var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　if (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; else &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　return quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>C语言版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define N 6</span><br><span class="line"></span><br><span class="line">int partition(int arr[], int low, int high)&#123;</span><br><span class="line">    int key; //key即为基准</span><br><span class="line">    key = arr[low];</span><br><span class="line">    while(low &lt; high)&#123;</span><br><span class="line">        while(low &lt;high &amp;&amp; arr[high] &gt;= key)</span><br><span class="line">            high--;</span><br><span class="line">        if(low&lt;high)</span><br><span class="line">        // 注意是先赋值后移动</span><br><span class="line">            arr[low++] = arr[high];</span><br><span class="line">        while(low &lt;high &amp;&amp; arr[low] &lt;= key)</span><br><span class="line">            low++;</span><br><span class="line">        if(low&lt;high)</span><br><span class="line">            arr[high--] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = key;</span><br><span class="line"></span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quick_sort(int arr[], int start, int end)&#123;</span><br><span class="line">    int pos;</span><br><span class="line">    if (start&lt;end)&#123;</span><br><span class="line">        pos = partition(arr, start, end);</span><br><span class="line">        quick_sort(arr,start,pos-1);</span><br><span class="line">        quick_sort(arr,pos+1,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int arr[N]=&#123;32,12,7, 78, 23,45&#125;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;排序前 \n&quot;);</span><br><span class="line">    for(i=0;i&lt;N;i++)</span><br><span class="line">        printf(&quot;%d\t&quot;,arr[i]);</span><br><span class="line">    quick_sort(arr,0,N-1);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n 排序后 \n&quot;);</span><br><span class="line">    for(i=0; i&lt;N; i++)</span><br><span class="line">        printf(&quot;%d\t&quot;, arr[i]);</span><br><span class="line">    printf (&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「归并排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。不断将已有序的子序列合并，最后得到一个统一的有序序列。</p>
<p>归并操作(从小到大）的工作原理如下：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并将该指针移动到下一位置（另一指向较大元素的指针位置不变）。</li>
<li>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾<a id="more"></a>
<h3 id="相关性质总结"><a href="#相关性质总结" class="headerlink" title="相关性质总结"></a>相关性质总结</h3></li>
<li>时间复杂度：O(n log n) ；</li>
<li>空间复杂度：O（N）；</li>
<li>排序性质：稳定</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex)</span><br><span class="line">&#123;</span><br><span class="line">//i 和 j分别指向两个有序数组的起始位置;k是排序后新数组的索引</span><br><span class="line">    int i = startIndex, j=midIndex+1, k = startIndex;</span><br><span class="line">    while(i!=midIndex+1 &amp;&amp; j!=endIndex+1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">        //tempArr为二路归并后的新数组</span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        else</span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    //剩下所有的元素都移到tempArr数组</span><br><span class="line">    while(i != midIndex+1)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    while(j != endIndex+1)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    for(i=startIndex; i&lt;=endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//内部使用递归</span><br><span class="line">void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)</span><br><span class="line">&#123;</span><br><span class="line">    int midIndex;</span><br><span class="line">    if(startIndex &lt; endIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        midIndex = (startIndex + endIndex) / 2;</span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+1, endIndex);</span><br><span class="line">        //最后将两个有序数组合并</span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a[8] = &#123;50, 10, 20, 30, 70, 40, 80, 60&#125;;</span><br><span class="line">    int i, b[8];</span><br><span class="line">    MergeSort(a, b, 0, 7);</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">        printf(&quot;%d &quot;, a[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「冒泡排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>冒泡重复地走访要排序的数列，一次比较最底下两个元素（即数列最前面两个元素），如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。每一轮交换都换产生余下数组最大的数，并冒到顶部。<br><a id="more"></a></p>
<h3 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h3><ol>
<li>时间复杂度：O(N^2)，进行N-1轮操作，每次进行n-1次交换</li>
<li>空间复杂度：O(N)</li>
<li>排序性质：内部排序，稳定排序</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>先列出一种效率较低的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int a[10] = &#123;1,4,3,5,23,2,45,6,3,5&#125;;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">      int i,j,mid;</span><br><span class="line">      int length = 10;</span><br><span class="line">      //开始外圈循环</span><br><span class="line">      for(i=0;i&lt;=9;i++)</span><br><span class="line">          //外圈循环到i时，说明该数组的后i-1个数已经排好序并且是最大值</span><br><span class="line">          for(j=0;j&lt;9-i;j++) </span><br><span class="line">          &#123;</span><br><span class="line">               if(a[j]&gt;=a[j+1])</span><br><span class="line">               &#123;</span><br><span class="line">                    mid = a[j];</span><br><span class="line">                    a[j] = a[j+1];</span><br><span class="line">                    a[j+1] = mid;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     </span><br><span class="line">      for(i=0;i&lt;=9;i++)</span><br><span class="line">          printf(&quot;%d   &quot;,a[i]);</span><br><span class="line">      system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个冒泡排序算法中有一个缺陷，如果数组是 2 1 3 4 5 6 ，那么在第一次外圈结束后，该数组就已经完成排序，但是程序还是会继续循环下去，做很多无用的比较，但是根本不会出现数的位置的交换。++所以我们需要考虑一下冒泡排序的结束条件++。</p>
<p>下面给出一个定义：如果冒泡排序在一次外圈的内圈循环中没有出现数的位置的交换，那么该数组排序完成，不需要向下进行。解释一下这个定义，内圈的循环是从0~length-i-1的，不出现交换说明在这个范围内后一个数都大于前一个数，而在length-i-1至lenth的范围中，本来就是符合条件的，所以定义成立。<br>所以我们添加一个flag标志，观察在每次外圈时是否出现数值的交换。<br>下面给出改进算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int a[10] = &#123;1,4,3,5,23,2,45,6,3,5&#125;;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">      int i,j,mid;</span><br><span class="line">      int length = 10;</span><br><span class="line">      int flag = 1;   //标识符</span><br><span class="line">      </span><br><span class="line">      for(i=0;i&lt;=9 &amp;&amp; flag;i++)   //注意判定条件</span><br><span class="line">          for(j=0;j&lt;9-i;j++)</span><br><span class="line">          &#123;</span><br><span class="line">               flag=0;        //每次外圈时初始化</span><br><span class="line">               if(a[j] &gt;= a[j+1])</span><br><span class="line">               &#123;</span><br><span class="line">                    mid = a[j];</span><br><span class="line">                    a[j] = a[j+1];</span><br><span class="line">                    a[j+1] = mid;</span><br><span class="line">                    flag=1;      //如果有交换，那么可以进入下一圈循环</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      for(i=0;i&lt;=9;i++)</span><br><span class="line">          printf(&quot;%d   &quot;,a[i]);</span><br><span class="line">      system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「插入排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<p><strong>前言：</strong>在【排序算法】板块中，我将纳入几种主流的排序算法学习笔记，代码以C为主，可能还会涉及我较熟悉的JavaScript</p>
<p><em>内容很基础，作为今后快速查阅的资料</em></p>
<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>插入排序是排序算法的一种，它不改变原有的序列（数组），而是创建一个新的序列，在新序列上进行操作。</p>
<p>基本思想是，将元素逐个添加到已经排序好的数组中去，同时要求，插入的元素必须在正确的位置，这样原来排序好的数组是仍然有序的。第i轮排序时，在前i个元素的子数组中插入第i+1个元素。直到所有元素都加入排序好数组。<strong>类似于打扑克牌的抓拍过程，每次抓一张新牌都将其插入到手里已经排好序的牌当中。</strong><br><a id="more"></a></p>
<h3 id="相关性质总结"><a href="#相关性质总结" class="headerlink" title="相关性质总结"></a>相关性质总结</h3><ol>
<li>时间复杂度：O(N平方),无论何种情况，要插入N个数首先必然要进行N轮操作，最坏情况下再交换N次，即N*N;</li>
<li>空间复杂度：O（N），即存储N个数字的空间</li>
<li>排序性质：插入排序是一种稳定的排序算法，不会改变原有序列中相同数字的顺序；均在内存中进行，为内部排序。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define N 8</span><br><span class="line">void insert_sort(int a[],int n);</span><br><span class="line">//插入排序实现,这里按从小到大排序</span><br><span class="line">void insert_sort(int a[],int n)//n为数组a的元素个数</span><br><span class="line">&#123;</span><br><span class="line">    //进行N-1轮插入过程</span><br><span class="line">    for(int i=1; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //首先找到元素a[i]需要插入的位置</span><br><span class="line">        int j=0;</span><br><span class="line">        while( (a[j]&lt;a[i]) &amp;&amp; (j&lt;i) )</span><br><span class="line">        &#123;</span><br><span class="line">            //这里a[j]实际为新构造的排序后的数组，j即为插入位置</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        //将元素插入到正确的位置</span><br><span class="line">        if(i != j)  //如果i==j，说明a[i]刚好在正确的位置</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = a[i];</span><br><span class="line">            for(int k = i; k &gt; j; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k] = a[k-1];//将插入位置以后的数都后移一位</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = temp;//将数字插入位置j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试 </span><br><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">    int num[N] = &#123;89, 38, 11, 78, 96, 44, 19, 25&#125;;</span><br><span class="line">    insert_sort(num, N);</span><br><span class="line">    for(int i=0; i&lt;N; i++)</span><br><span class="line">        printf(&quot;%d  &quot;, num[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客上线小记]]></title>
      <url>http://yoursite.com/2016/05/22/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><del>写在前面的屁话</del></p>
<pre><code>好久没有碰工程项目啦！自从大二在工作室接外包做了几个项目之后，除了课程相关的代码，
就再也没有实际的写过东西了，这段时间趁着导师内边事情不多，把自己的博客搭起来，也算练练手吧。
</code></pre><h3 id="为什么要搭建个人博客"><a href="#为什么要搭建个人博客" class="headerlink" title="为什么要搭建个人博客"></a>为什么要搭建个人博客</h3><ul>
<li><p><strong>记录</strong>：自从高中毕业之后，很少用心写作了（说的好像高中作文也是用心写的一样）。决心利用博客重新开始写作，主要用来记录自己的技术成长路线，偶尔也会用来表达生活感悟。</p>
</li>
<li><p><strong>分享</strong>：过去我看过很多的个人博客（几乎是程序猿标配了），却一直没有抽时间搭建属于自己的博客。现在觉得还是得把它建起来，主要为自己记录，最好也能为他人做微不足道的分享。其实一直有想法找个地方写写东西，新浪博客、CSDN、微信公众号都有尝试，还有幸作为知乎专栏内测用户，但是都没有坚持下去，希望这里能够记录更多的内容吧。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="怎么搭建个人博客"><a href="#怎么搭建个人博客" class="headerlink" title="怎么搭建个人博客"></a>怎么搭建个人博客</h3><p>阮一峰老师说过，博客的搭建会经历三个阶段:</p>
<blockquote>
<p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</p>
<p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p>
<p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<p>  这里我选择了第二种方式，但是抱着急功近利的心态，连最初计划的后端Thinkphp + 前端bootstrap框架的方法都放弃了，直接用了github的开源框架hexo…（ 羞耻脸</p>
<p>  全站自己写的东西不多，用了无数轮子，主要功夫都花在配环境和「移花接木」上了。</p>
<hr>
<p>  <em>2016.05.22晚</em></p>
<p> 买了自己的独立域名，算是正式上线的开始吧，<br> 原本是想买最直接的”www.kangkai.com”,即姓名全拼+com后缀，无奈也不出意外地被注册了，连cn,org等传统顶级域名都被注册了….</p>
<p> 只好另辟蹊径，发现了.science后缀觉得挺有big的。。就果断买了下来（到2018年都是我的哈哈哈）</p>
<p>  之前建设过程中迭代过几个版本，这里就不一一详细记录了，今后有功能上的变化都会把过程和技术难点以博客形式记录。上一版中增加了文章末尾的微信打赏二维码和RSS订阅功能，优化了评论框（多说接口）的性能和UI设计，不存在技术上问题。</p>
<p>  差不多了，我去看电影了，bye~</p>
<p>  <strong>喜欢我的博客或者发现bug欢迎留言！</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dijkstra's algorithm]]></title>
      <url>http://yoursite.com/2016/05/19/Dijkstra-s-algorithm/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Dijkstra’s algorithm</strong></p>
<h2 id="Dijkstra’s-algorithm-is-an-algorithm-for-finding-the-shortest-paths-between-nodes-in-a-graph-which-may-represent-for-example-road-networks-It-was-conceived-by-computer-scientist-Edsger-W-Dijkstra-in-1956-and-published-three-years-later"><a href="#Dijkstra’s-algorithm-is-an-algorithm-for-finding-the-shortest-paths-between-nodes-in-a-graph-which-may-represent-for-example-road-networks-It-was-conceived-by-computer-scientist-Edsger-W-Dijkstra-in-1956-and-published-three-years-later" class="headerlink" title="Dijkstra’s algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later."></a>Dijkstra’s algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</h2><p>戴克斯特拉算法（英语：Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。<br><a id="more"></a></p>
<pre><code>   function Dijkstra(G, w, s)
      for each vertex v in V[G]                        // 初始化
            d[v] := infinity                                 // 將各點的已知最短距離先設成無窮大
            previous[v] := undefined                         // 各点的已知最短路径上的前趋都未知
     d[s] := 0                                              // 因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0
      S := empty set
      Q := set of all vertices
      while Q is not an empty set                      // Dijkstra演算法主體
            u := Extract_Min(Q)
10           S.append(u)
11           for each edge outgoing from u as (u,v)
12                  if d[v] &gt; d[u] + w(u,v)             // 拓展边（u,v）。w(u,v)为从u到v的路径长度。
13                        d[v] := d[u] + w(u,v)               // 更新路径长度到更小的那个和值。
14                        previous[v] := u                    // 紀錄前趨頂點
</code></pre><p>该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t 的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。</p>
<p>最初的戴克斯特拉算法不采用最小优先级队列，时间复杂度是O(|V|^2)(其中|V|为图的顶点个数)。通过斐波那契堆实现的迪科斯彻算法时间复杂度是O(|E|+|V|\log|V|) (其中|E|是边数) （Fredman &amp; Tarjan 1984）。对于不含负权的有向图，这是目前已知的最快的单源最短路径算法。</p>
<p>如果我们只对在 s 和 t 之间查找一条最短路径的话，我们可以在第9行添加条件如果满足 u = t 的话终止程序。</p>
<p>通过推导可知，为了记录最佳路径的轨迹，我们只需记录该路径上每个点的前趋，即可通过迭代来回溯出 s 到 t 的最短路径（当然，使用后继节点来存储亦可。但那需要修改代码）：</p>
<pre><code>1 s := empty sequence 
2 u := t
3 while defined u                                        
4       insert u to the beginning of S
5       u := previous[u]      //previous数组即为上文中的p
</code></pre>]]></content>
    </entry>
    
  
  
</search>
