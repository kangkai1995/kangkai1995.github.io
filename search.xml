<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[我的个人博客正式上线啦~]]></title>
      <url>http://yoursite.com/2016/05/22/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%AD%A3%E5%BC%8F%E4%B8%8A%E7%BA%BF%E5%95%A6/</url>
      <content type="html"><![CDATA[<p><del>写在前面的屁话</del></p>
<pre><code>好久没有碰工程项目啦！自从大二在工作室接外包做了几个项目之后，除了课程相关的代码，
就再也没有实际的写过东西了，这段时间趁着导师内边事情不多，把自己的博客搭起来，也算练练手吧。
</code></pre><h3 id="为什么要搭建个人博客"><a href="#为什么要搭建个人博客" class="headerlink" title="为什么要搭建个人博客"></a>为什么要搭建个人博客</h3><ul>
<li><p><strong>记录</strong>：自从高中毕业之后，很少用心写作了（说的好像高中作文也是用心写的一样）。决心利用博客重新开始写作，主要用来记录自己的技术成长路线，偶尔也会用来表达生活感悟。</p>
</li>
<li><p><strong>分享</strong>：过去我看过很多的个人博客（几乎是程序猿标配了），却一直没有抽时间搭建属于自己的博客。现在觉得还是得把它建起来，主要为自己记录，最好也能为他人做微不足道的分享。其实一直有想法找个地方写写东西，新浪博客、CSDN、微信公众号都有尝试，还有幸作为知乎专栏内测用户，但是都没有坚持下去，希望这里能够记录更多的内容吧。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="怎么搭建个人博客"><a href="#怎么搭建个人博客" class="headerlink" title="怎么搭建个人博客"></a>怎么搭建个人博客</h3><p>阮一峰老师说过，博客的搭建会经历三个阶段:</p>
<blockquote>
<p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</p>
<p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p>
<p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<p>  这里我选择了第二种方式，但是抱着急功近利的心态，连最初计划的后端Thinkphp + 前端bootstrap框架的方法都放弃了，直接用了github的开源框架hexo…（ 羞耻脸</p>
<p>  全站自己写的东西不多，用了无数轮子，主要功夫都花在配环境和「移花接木」上了。</p>
<hr>
<p>  <em>2016.05.22晚</em></p>
<p> 买了自己的独立域名，算是正式上线的开始吧，<br> 原本是想买最直接的”www.kangkai.com”,即姓名全拼+com后缀，无奈也不出意外地被注册了，连cn,org等传统顶级域名都被注册了….</p>
<p> 只好另辟蹊径，发现了.science后缀觉得挺有big的。。就果断买了下来（到2018年都是我的哈哈哈）</p>
<p>  之前建设过程中迭代过几个版本，这里就不一一详细记录了，今后有功能上的变化都会把过程和技术难点以博客形式记录。上一版中增加了文章末尾的微信打赏二维码和RSS订阅功能，优化了评论框（多说接口）的性能和UI设计，不存在技术上问题。</p>
<p>  差不多了，我去看电影了，bye~</p>
<p>  <strong>喜欢我的博客或者发现bug欢迎留言！</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dijkstra's algorithm]]></title>
      <url>http://yoursite.com/2016/05/19/Dijkstra-s-algorithm/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Dijkstra’s algorithm</strong></p>
<h2 id="Dijkstra’s-algorithm-is-an-algorithm-for-finding-the-shortest-paths-between-nodes-in-a-graph-which-may-represent-for-example-road-networks-It-was-conceived-by-computer-scientist-Edsger-W-Dijkstra-in-1956-and-published-three-years-later"><a href="#Dijkstra’s-algorithm-is-an-algorithm-for-finding-the-shortest-paths-between-nodes-in-a-graph-which-may-represent-for-example-road-networks-It-was-conceived-by-computer-scientist-Edsger-W-Dijkstra-in-1956-and-published-three-years-later" class="headerlink" title="Dijkstra’s algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later."></a>Dijkstra’s algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</h2><p>戴克斯特拉算法（英语：Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。</p>
<pre><code>   function Dijkstra(G, w, s)
      for each vertex v in V[G]                        // 初始化
            d[v] := infinity                                 // 將各點的已知最短距離先設成無窮大
            previous[v] := undefined                         // 各点的已知最短路径上的前趋都未知
     d[s] := 0                                              // 因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0
      S := empty set
      Q := set of all vertices
      while Q is not an empty set                      // Dijkstra演算法主體
            u := Extract_Min(Q)
10           S.append(u)
11           for each edge outgoing from u as (u,v)
12                  if d[v] &gt; d[u] + w(u,v)             // 拓展边（u,v）。w(u,v)为从u到v的路径长度。
13                        d[v] := d[u] + w(u,v)               // 更新路径长度到更小的那个和值。
14                        previous[v] := u                    // 紀錄前趨頂點
</code></pre><a id="more"></a>
<p>该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t 的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。</p>
<p>最初的戴克斯特拉算法不采用最小优先级队列，时间复杂度是O(|V|^2)(其中|V|为图的顶点个数)。通过斐波那契堆实现的迪科斯彻算法时间复杂度是O(|E|+|V|\log|V|) (其中|E|是边数) （Fredman &amp; Tarjan 1984）。对于不含负权的有向图，这是目前已知的最快的单源最短路径算法。</p>
<p>如果我们只对在 s 和 t 之间查找一条最短路径的话，我们可以在第9行添加条件如果满足 u = t 的话终止程序。</p>
<p>通过推导可知，为了记录最佳路径的轨迹，我们只需记录该路径上每个点的前趋，即可通过迭代来回溯出 s 到 t 的最短路径（当然，使用后继节点来存储亦可。但那需要修改代码）：</p>
<pre><code>1 s := empty sequence 
2 u := t
3 while defined u                                        
4       insert u to the beginning of S
5       u := previous[u]      //previous数组即为上文中的p
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/2016/05/19/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%E3%80%90%E6%B5%8B%E8%AF%95%E7%94%A8%E3%80%91/</url>
      <content type="html"><![CDATA[<h1 id="第一篇博文【测试用】"><a href="#第一篇博文【测试用】" class="headerlink" title="第一篇博文【测试用】"></a>第一篇博文【测试用】</h1><blockquote>
<p>冼星海：我们的幸福是以解放民族，解放人类为目的</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
