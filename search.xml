<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[【java】之「synchronized同步方法」]]></title>
      <url>http://yoursite.com/2017/03/19/%E3%80%90java%E3%80%91%E4%B9%8B%E3%80%8Csynchronized%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E3%80%8D/</url>
      <content type="html"><![CDATA[<h3 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h3><p>synchronized是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。在了解synchronized关键字的使用方法之前，我们先来看一个概念：互斥锁，顾名思义：能到达到互斥访问目的的锁。</p>
<p>举个简单的例子：如果对临界资源加上互斥锁，当一个线程在访问该临界资源时，其他线程便只能等待。</p>
<p><strong>在Java中，每一个对象都拥有一个锁标记（monitor），也称为监视器，多线程同时访问某个对象时，线程只有获取了该对象的锁才能访问。</strong></p>
<a id="more"></a>
<p>在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</p>
<h3 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h3><p>synchronized代码块，被修饰的代码成为同步语句块，<strong>其作用的范围是调用这个代码块的对象</strong>，我们在用synchronized关键字的时候，<strong>能缩小代码段的范围就尽量缩小</strong>，能在代码段上加同步就不要再整个方法上加同步。<strong>这叫减小锁的粒度，使代码更大程度的并发。</strong></p>
<p>synchronized方法，被修饰的方法成为同步方法，其作用范围是整个方法，作用对象是调用这个方法的对象。</p>
<p>synchronized静态方法，修饰一个static静态方法，其作用范围是整个静态方法，作用对象是这个类的所有对象。</p>
<p>synchronized()，()中是锁住的对象， synchronized(this)锁住的只是对象本身，同一个类的不同对象调用的synchronized方法并不会被锁住，而synchronized(className.class)实现了全局锁的功能，所有这个类的对象调用这个方法都受到锁的影响，此外()中还可以添加一个具体的对象，实现给具体对象加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (object) &#123;</span><br><span class="line">//在同步代码块中对对象进行操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Q-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#Q-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="Q: 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>Q: 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h4><p>A：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。<br>因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，<strong>如果已经进入A方法说明对象锁已经被取走</strong>，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【java】之「static方法不能直接访问非static成员缘由」]]></title>
      <url>http://yoursite.com/2017/03/19/%E3%80%90java%E3%80%91%E4%B9%8B%E3%80%8Cstatic%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E9%9D%9Estatic%E6%88%90%E5%91%98%E7%BC%98%E7%94%B1%E3%80%8D/</url>
      <content type="html"><![CDATA[<p>static成员是在JVM的CLASSLOADER加载类的时候初始化的，而非static的成员是在创建对象，即new 操作的时候才初始化的；类加载的时候初始化static的成员，此时static 已经分配内存空间，所以可以访问；非static的成员还没有通过new创建对象而进行初始化，所以必然不可以访问。</p>
<p>简单点说： <strong>静态成员属于类,不需要生成对象就存在了。而非静态需要生成对象才产生，所以静态成员不能直接访问。 </strong></p>
<a id="more"></a>
<h3 id="下面说说静态的特点："><a href="#下面说说静态的特点：" class="headerlink" title="下面说说静态的特点："></a>下面说说静态的特点：</h3><p>1.随着类的加载而加载——静态会随着类的消失而消失，说明静态的生命周期最长<br> 2.优先于对象的存在——静态是先存在的，对象是后存在的<br> 3.被所有对象共享<br>4.可以直接被类名所调用<br>静态的使用注意事项：</p>
<ol>
<li><p>静态方法只能访问静态成员（包括成员变量和成员方法） 非静态方法可以访问静态也可以访问非静态</p>
</li>
<li><p>静态方法中不可以定义this，super关键字 因为 一个类中，一个static变量只会有一个内存空间，虽然有多个类实例，但这些类实例中的这个static变量会共享同一个内存空间。静态方法在优先于对象存在，所以静态方法中不可以出现this，super关键字。</p>
</li>
<li><p>主函数是静态的。</p>
</li>
</ol>
<h3 id="静态的利弊："><a href="#静态的利弊：" class="headerlink" title="静态的利弊："></a>静态的利弊：</h3><p>利：对对象的共享数据进行单独空间的存储，节省空间，没有必要每一个对象中都存储一份，可以直接被类名所调用</p>
<p>弊：生命周期过长，访问出现局限性（只能访问静态）</p>
<p>实例变量和类变量（static声明的变量）的区别：</p>
<ol>
<li><p>存放位置 ：类变量随着类的加载存在于方法区中，实例变量随着对象的建立存在于堆内存里</p>
</li>
<li><p>生命周期 ：类变量生命周期最长，随着“类”的加载而加载，随着类的消失而消失 实例变量随着“对象”的消失而消失</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【java】之「线程的状态」]]></title>
      <url>http://yoursite.com/2017/03/18/%E3%80%90java%E3%80%91%E4%B9%8B%E3%80%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%8D/</url>
      <content type="html"><![CDATA[<h3 id="java的多线程含以下几种状态"><a href="#java的多线程含以下几种状态" class="headerlink" title="java的多线程含以下几种状态"></a>java的多线程含以下几种状态</h3><ol>
<li><p>新建( new )：新创建了一个线程对象。</p>
</li>
<li><p>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</p>
</li>
<li><p>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</p>
</li>
</ol>
<ol>
<li><p>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<br>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。<br>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</p>
</li>
<li><p>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
</li>
</ol>
<p><img src="http://uploadfiles.nowcoder.com/images/20151217/149974_1450349079825_4697A22AC611680A692472687DEC1CFD" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【java】之「static class 静态类」]]></title>
      <url>http://yoursite.com/2017/03/18/%E3%80%90java%E3%80%91%E4%B9%8B%E3%80%8Cstatic%20class%20%E9%9D%99%E6%80%81%E7%B1%BB%E3%80%8D/</url>
      <content type="html"><![CDATA[<h3 id="static-class-静态类（Java）"><a href="#static-class-静态类（Java）" class="headerlink" title="static class 静态类（Java）　"></a>static class 静态类（Java）　</h3><p>一般情况下是不可以用static修饰类的。如果一定要用static修饰类的话，通常static修饰的是匿名内部类。<br>在一个类中创建另外一个类，叫做成员内部类。这个成员内部类可以静态的（利用static关键字修饰），也可以是非静态的。由于静态的内部类在定义、使用的时候会有种种的限制。所以在实际工作中用到的并不多。</p>
<p>在开发过程中，内部类中使用的最多的还是非静态地成员内部类。不过在特定的情况下，静态内部类也能够发挥其独特的作用。</p>
<a id="more"></a>
<h4 id="一、静态内部类的使用目的。"><a href="#一、静态内部类的使用目的。" class="headerlink" title="　　一、静态内部类的使用目的。"></a>　　一、静态内部类的使用目的。</h4><p>　　在定义内部类的时候，可以在其前面加上一个权限修饰符static。此时这个内部类就变为了静态内部类。不过由于种种的原因，如使用上的限制等等因素(具体的使用限制，笔者在下面的内容中会详细阐述)，在实际工作中用的并不是很多。但是并不是说其没有价值。在某些特殊的情况下，少了这个静态内部类还真是不行。如在进行代码程序测试的时候，如果在每一个Java源文件中都设置一个主方法(主方法是某个应用程序的入口，必须具有)，那么会出现很多额外的代码。<strong>而且最主要的是这段主程序的代码对于Java文件来说，只是一个形式，其本身并不需要这种主方法。但是少了这个主方法又是万万不行的。在这种情况下，就可以将主方法写入到静态内部类中，从而不用为每个Java源文件都设置一个类似的主方法</strong>。这对于代码测试是非常有用的。在一些中大型的应用程序开发中，则是一个常用的技术手段。为此，这个静态内部类虽然不怎么常用，但是程序开发人员还必须要掌握它。也许在某个关键的时刻，其还可以发挥巨大的作用也说不定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MainInStaticClass &#123;</span><br><span class="line"> </span><br><span class="line"> static class Main&#123;</span><br><span class="line">static void main() &#123;</span><br><span class="line">//将主方法写到静态内部类中，从而不必为每个源文件都这种一个类似的主方法</span><br><span class="line">new MainInStaticClass().print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">new MainInStaticClass().print();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void print()&#123;</span><br><span class="line">System.out.println(&quot;main in static inner class&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class TestMain &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">// new MainInStaticClass().print();</span><br><span class="line">MainInStaticClass.Main.main();</span><br><span class="line">new MainInStaticClass.Main();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　</p>
<h4 id="二、静态内部类的使用限制。"><a href="#二、静态内部类的使用限制。" class="headerlink" title="二、静态内部类的使用限制。"></a>二、静态内部类的使用限制。</h4><p>　　将某个内部类定义为静态类，跟将其他类定义为静态类的方法基本相同，引用规则也基本一致。不过其细节方面仍然有很大的不同。具体来说，主要有如下几个地方要引起各位程序开发人员的注意。</p>
<p>　　一是静态成员(包括静态变量与静态成员)的定义。一般情况下，如果一个内部类不是被定义成静态内部类，那么在定义成员变量或者成员方法的时候，是不能够被定义成静态成员变量与静态成员方法的。也就是说，在非静态内部类中不可以声明静态成员。如现在在一个student类中定义了一个内部类age，如果没有将这个类利用static关键字修饰，即没有定义为静态类，那么在这个内部类中如果要利用static关键字来修饰某个成员方法或者成员变量是不允许的。在编译的时候就通不过。<br>　　故程序开发人员需要注意，只有将某个内部类修饰为静态类，然后才能够在这个类中定义静态的成员变量与成员方法。这是静态内部类都有的一个特性。也正是因为这个原因，有时候少了这个静态的内部类，很多工作就无法完成。或者说要绕一个大圈才能够实现某个用户的需求。这也是静态的内部类之所以要存在的一个重要原因。</p>
<p>后注：经过大家的指正，现声明：非静态内部类也可以定义静态成员但需要同时有final关键词修饰，静态方法鉴于无法用final修饰，仍必须是在静态内部类 或者非内部类中定义。</p>
<p>　　二是在成员的引用上，有比较大的限制。一般的非静态内部类，可以随意的访问外部类中的成员变量与成员方法。即使这些成员方法被修饰为private(私有的成员变量或者方法)，其非静态内部类都可以随意的访问。则是非静态内部类的特权。因为在其他类中是无法访问被定义为私有的成员变量或则方法。但是如果一个内部类被定义为静态的，那么在银用外部类的成员方法或则成员变量的时候，就会有诸多的限制。如不能够从静态内部类的对象中访问外部类的非静态成员(包括成员变量与成员方法)。这是什么意思呢?如果在外部类中定义了两个变量，一个是非静态的变量，一个是静态的变量。那么在静态内部类中，无论在成员方法内部还是在其他地方，都只能够引用外部类中的静态的变量，而不能够访问非静态的变量。在静态内部类中，可以定义静态的方法(也只有在静态的内部类中可以定义静态的方法)，在静态方法中引用外部类的成员。但是无论在内部类的什么地方引用，有一个共同点，即都只能够引用外部类中的静态成员方法或者成员变量。对于那些非静态的成员变量与成员方法，在静态内部类中是无法访问的。这就是静态内部类的最大使用限制。在普通的非静态内部类中是没有这个限制的。也正是这个原因，决定了静态内部类只应用在一些特定的场合。其应用范围远远没有像非静态的内部类那样广泛。</p>
<h4 id="三是在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。"><a href="#三是在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。" class="headerlink" title="　三是在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。"></a>　三是在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。</h4><p>通常情况下，<strong>在一个类中创建成员内部类的时候，有一个强制性的规定，即内部类的实例一定要绑定在外部类的实例中</strong>。也就是说，在创建内部类之前要先在外部类中要利用new关键字来创建这个内部类的对象。如此的话如果从外部类中初始化一个内部类对象，那么内部类对象就会绑定在外部类对象上。也就是说，普通非静态内部类的对象是依附在外部类对象之中的。但是，如果成员开发人员创建的时静态内部类，那么这就又另当别论了。通常情况下，程序员在定义静态内部类的时候，是不需要定义绑定在外部类的实例上的。也就是说，要在一个外部类中定义一个静态的内部类，不需要利用关键字new来创建内部类的实例。即在创建静态类内部对象时，不需要其外部类的对象。</p>
<p>new MainInStaticClass.Main();</p>
<p>具体为什么会这样，一般程序开发人员不需要了解这么深入，只需要记住有这个规则即可。在定义静态内部类的时候，千万不要犯画蛇添足的错误。</p>
<p>　　从以上的分析中可以看出，静态内部类与非静态的内部类还是有很大的不同的。一般程序开发人员可以这么理解，<strong>非静态的内部类对象隐式地在外部类中保存了一个引用，指向创建它的外部类对象</strong>。不管这么理解，程序开发人员都需要牢记静态内部类与非静态内部类的差异。如是否可以创建静态的成员方法与成员变量(静态内部类可以创建静态的成员而非静态的内部类不可以)、对于访问外部类的成员的限制(静态内部类只可以访问外部类中的静态成员变量与成员方法而非静态的内部类即可以访问静态的也可以访问非静态的外部类成员方法与成员变量)。这两个差异是静态内部类与非静态外部类最大的差异，也是静态内部类之所以存在的原因。了解了这个差异之后，程序开发人员还需要知道，在什么情况下该使用静态内部类。如在程序测试的时候，为了避免在各个Java源文件中书写主方法的代码，可以将主方法写入到静态内部类中，以减少代码的书写量，让代码更加的简洁。</p>
<p>　　总之，静态内部类在Java语言中是一个很特殊的类，跟普通的静态类以及非静态的内部类都有很大的差异。作为程序开发人员，必须要知道他们之间的差异，并在实际工作中在合适的地方采用合适的类。不过总的来说，静态内部类的使用频率并不是很高。但是在有一些场合，如果没有这个内部静态类的话，可能会起到事倍功半的反面效果</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Java】 之 「JVM堆内存和栈内存详解」]]></title>
      <url>http://yoursite.com/2017/03/12/%E3%80%90Java%E3%80%91%20%E4%B9%8B%20%E3%80%8CJVM%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3%E3%80%8D/</url>
      <content type="html"><![CDATA[<p>Java把内存分成两种，一种叫做栈内存，一种叫做堆内存</p>
<p>在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。<strong>当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。</strong></p>
<p><strong>堆内存用于存放由new创建的对象和数组</strong>。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，<strong>这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量</strong>，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。 引用变量是普通变量，定义时在栈中分配内存，<strong>引用变量在程序运行到作用域外释放</strong>。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，<strong>数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用</strong>，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，<strong>栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</strong></p>
<a id="more"></a>
<p>java中内存分配策略及堆和栈的比较</p>
<p>1 内存分配策略</p>
<p>按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的.</p>
<p>静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求.</p>
<p>栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。</p>
<p>静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放.</p>
<p>2 堆和栈的比较</p>
<p>上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈:</p>
<p>从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的:</p>
<p>在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时.</p>
<p>堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~).</p>
<p>3 JVM中的堆和栈</p>
<p>JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</p>
<p>我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的.</p>
<p>从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p>
<p>每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。</p>
<p>Java 中的堆和栈</p>
<p>Java把内存划分成两种：一种是栈内存，一种是堆内存。</p>
<p>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。</p>
<p>当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p>
<p>堆内存用来存放由new创建的对象和数组。</p>
<p>在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p>
<p>在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。</p>
<p>引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。</p>
<p>具体的说：</p>
<p>栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p>
<p>Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p>
<p>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int, short, long, byte, float, double, boolean, char)和对象句柄。</p>
<p>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：</p>
<p>int a = 3;</p>
<p>int b = 3;</p>
<p>编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Database] - 数据库四种隔离级别]]></title>
      <url>http://yoursite.com/2017/03/12/%E3%80%90Database%E3%80%91-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      <content type="html"><![CDATA[<ul>
<li><p>（零）没有并发控制</p>
<p>  存在的问题：更新遗失。<br>  解决办法就是下面的“可读取未确认”。</p>
</li>
<li><p>（一）可读取未确认（Read uncommitted）</p>
<p>  写事务阻止其他写事务，避免了更新遗失。但是没有阻止其他读事务。<br>  存在的问题：脏读。即读取到不正确的数据，因为另一个事务可能还没提交最终数据，这个读事务就读取了中途的数据，这个数据可能是不正确的。<br>  解决办法就是下面的“可读取确认”。</p>
<a id="more"></a></li>
<li><p>（二）可读取确认（Read committed）<br>  写事务会阻止其他读写事务。读事务不会阻止其他任何事务。 </p>
<p>  存在的问题：不可重复读。即在一次事务之间，进行了两次读取，但是结果不一样，可能第一次id为1的人叫“李三”，第二次读id为1的人就叫了“李四”。因为读取操作不会阻止其他事务。<br>解决办法就是下面的“可重复读”。</p>
</li>
<li><p>（三）可重复读（Repeatable read）</p>
<p>  读事务会阻止其他写事务，但是不会阻止其他读事务。<br>  存在的问题：幻读。可重复读阻    止的写事务包括update和delete（只给存在的表加上了锁），但是不包括insert（新行不存在，所以没有办法加锁），所以一个事务第一次读取可能读取到了10条记录，但是第二次可能读取到11条，这就是幻读。<br>  解决办法就是下面的“串行化”。</p>
</li>
<li><p>（四）可串行化（Serializable）</p>
<p>  读加共享锁，写加排他锁。这样读取事务可以并发，但是读写，写写事务之间都是互斥的，基本上就是一个个执行事务，所以叫串行化。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Java】 之 「demo版租车系统」]]></title>
      <url>http://yoursite.com/2017/02/10/%E3%80%90Java%E3%80%91%20%E4%B9%8B%20%E3%80%8Cdemo%E7%89%88%E7%A7%9F%E8%BD%A6%E7%B3%BB%E7%BB%9F%E3%80%8D/</url>
      <content type="html"><![CDATA[<p><strong>前言：</strong><br>最近重新学了一遍java, 两年没碰过，显得很生疏。从最基本的语法开始，到封装/多态/继承的概念,以及抽象类/接口都过了一遍。</p>
<p>写点代码练练手，撸了一个很初级的租车系统，仅为重温以上所提内容。</p>
<p><strong>实现如下：</strong><br><a id="more"></a></p>
<p>父类Car</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">// 定义抽象类Car</span><br><span class="line">public abstract class Car &#123;</span><br><span class="line">	//车的种类</span><br><span class="line">	public String carType;</span><br><span class="line">	//租车的价格</span><br><span class="line">	public int rentPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>载人接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">//定义载人这个行为的接口</span><br><span class="line">public interface IPassengerCapacity &#123;</span><br><span class="line">	//默认会赋成抽象方法(不能有方法体)</span><br><span class="line">	public int getPassengerCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>载货接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">//定义载货这个行为的接口</span><br><span class="line">public interface IGoodsCapacity &#123;</span><br><span class="line">	public int getGoodsCapacity(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>载人车类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">// 定义只可以载人的汽车，实现了IPassengerCapacity接口</span><br><span class="line">public class PassengerCar extends Car implements IPassengerCapacity &#123;</span><br><span class="line">	//定义私有变量表示载客量</span><br><span class="line">	private int passengerCapacity;</span><br><span class="line">	//定义带参数的构造方法，以初始化新车</span><br><span class="line">	PassengerCar(String type, int rentPrice, int passengerCapacity)&#123;</span><br><span class="line">		// carType和rentPrice变量继承至抽象类car</span><br><span class="line">		this.carType = type; </span><br><span class="line">		this.rentPrice = rentPrice;</span><br><span class="line">		//passengerCapacity为PassengerCar新定义的私有变量</span><br><span class="line">		this.passengerCapacity = passengerCapacity;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	//覆写了接口中的抽象方法</span><br><span class="line">	public int getPassengerCapacity() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return passengerCapacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>卡车类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line"></span><br><span class="line">public class Trunk extends Car implements IGoodsCapacity &#123;</span><br><span class="line">	private int goodCapacity;</span><br><span class="line">	Trunk(String type, int rentPrice, int goodCapacity)&#123;</span><br><span class="line">		this.carType = type;</span><br><span class="line">		this.rentPrice = rentPrice;</span><br><span class="line">		this.goodCapacity = goodCapacity;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int getGoodsCapacity() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return goodCapacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>皮卡类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package rentCarSystem;</span><br><span class="line">// 定义皮卡类，既可以载人又可以载客，故同时实现了两个接口</span><br><span class="line">public class Pickup extends Car implements IGoodsCapacity, IPassengerCapacity &#123;</span><br><span class="line">	private int goodCapacity;</span><br><span class="line">	private int passengerCapacity;</span><br><span class="line">	public Pickup(String type, int rentPrice, int goodCapacity, int passengerCapacity) &#123;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">		this.carType = type;</span><br><span class="line">		this.rentPrice = rentPrice;</span><br><span class="line">		this.goodCapacity = goodCapacity;</span><br><span class="line">		this.passengerCapacity = passengerCapacity;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int getPassengerCapacity() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return passengerCapacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int getGoodsCapacity() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return goodCapacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rentCarSystem;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Initial</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//定义一个数组，存储初始化过的车辆</span></span><br><span class="line">		Car[] CarsforRent= &#123;<span class="keyword">new</span> PassengerCar(<span class="string">"宝马Z4"</span>, <span class="number">800</span>, <span class="number">2</span>),<span class="keyword">new</span> PassengerCar(<span class="string">"金龙大巴"</span>, <span class="number">600</span>, <span class="number">30</span>),<span class="keyword">new</span> Trunk(<span class="string">"拖拉机"</span>, <span class="number">200</span>, <span class="number">10</span>),<span class="keyword">new</span> Pickup(<span class="string">"皮卡"</span>, <span class="number">300</span>, <span class="number">5</span>, <span class="number">4</span>)&#125;;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"*******欢迎来到租车系统******"</span>);</span><br><span class="line">		System.out.println(<span class="string">"hi,你是否要租车? Y/N"</span>);</span><br><span class="line">		<span class="comment">//仅为一个demo. 所有输入都不做非法输入处理</span></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		String isRent = input.next().toUpperCase();</span><br><span class="line">		<span class="keyword">if</span>(isRent.equals(<span class="string">"Y"</span>))&#123;</span><br><span class="line">			System.out.println(<span class="string">"以下是您可选择的租车详情"</span>);</span><br><span class="line">			System.out.println(<span class="string">"序号\t类型\t日租金\t容量"</span>);</span><br><span class="line">			<span class="keyword">int</span> carID = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(Car newcar : CarsforRent)&#123;</span><br><span class="line">				<span class="keyword">if</span>(newcar <span class="keyword">instanceof</span> PassengerCar)&#123;</span><br><span class="line">					<span class="comment">//注意在拿到乘客数量的时候要做类型转换</span></span><br><span class="line">					System.out.println(carID +<span class="string">".\t"</span> +newcar.carType+ <span class="string">"\t"</span> +newcar.rentPrice+ <span class="string">"\t"</span> +<span class="string">"载人："</span>+((PassengerCar)newcar).getPassengerCapacity()+ <span class="string">"人"</span> );</span><br><span class="line">					carID++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(newcar <span class="keyword">instanceof</span> Trunk)&#123;</span><br><span class="line">					System.out.println(carID +<span class="string">".\t"</span> +newcar.carType+ <span class="string">"\t"</span> +newcar.rentPrice+ <span class="string">"\t"</span> +<span class="string">"载货："</span>+((Trunk)newcar).getGoodsCapacity()+ <span class="string">"吨"</span> );</span><br><span class="line">					carID++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(newcar <span class="keyword">instanceof</span> Pickup)&#123;</span><br><span class="line">					System.out.println(carID +<span class="string">".\t"</span> +newcar.carType+ <span class="string">"\t"</span> +newcar.rentPrice+ <span class="string">"\t"</span> +<span class="string">"载人："</span>+((Pickup)newcar).getPassengerCapacity()+ <span class="string">"人；"</span> +<span class="string">"载货："</span>+((Pickup)newcar).getGoodsCapacity()+ <span class="string">"吨"</span> );</span><br><span class="line">					carID++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"请输入您要租车的数量(1-4辆):"</span>);</span><br><span class="line">			<span class="keyword">int</span> carQuantity = input.nextInt();</span><br><span class="line">			<span class="comment">//新建一个长度为租车数量的数组来储存用户选中的车的序号</span></span><br><span class="line">			<span class="keyword">int</span>[] selectedCarsIndex = <span class="keyword">new</span> <span class="keyword">int</span>[carQuantity];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; carQuantity; i++)&#123;</span><br><span class="line">				System.out.println(<span class="string">"请输入欲租第"</span>+(i+<span class="number">1</span>)+<span class="string">"辆车的序号(1-4)："</span>);</span><br><span class="line">				selectedCarsIndex[i] = input.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"请输入您要用车的天数:"</span>);</span><br><span class="line">			<span class="keyword">int</span> useDays=input.nextInt(); </span><br><span class="line">			<span class="keyword">int</span> passengerSum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> goodSum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> moneySum=<span class="number">0</span>;</span><br><span class="line">			System.out.println(<span class="string">"***预定完成，您的订单如下： \n可载人的车辆有： "</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; carQuantity; i++)&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>] <span class="keyword">instanceof</span> PassengerCar )&#123;</span><br><span class="line">					passengerSum += ((PassengerCar)CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>]).getPassengerCapacity();</span><br><span class="line">					System.out.print(CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>].carType+<span class="string">":"</span>+((PassengerCar)CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>]).getPassengerCapacity() +<span class="string">"人;"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>] <span class="keyword">instanceof</span> Pickup)&#123;</span><br><span class="line">					passengerSum += ((Pickup)CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>]).getPassengerCapacity();</span><br><span class="line">					System.out.print(CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>].carType+<span class="string">":"</span>+((Pickup)CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>]).getPassengerCapacity() +<span class="string">"人;"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				moneySum += CarsforRent[selectedCarsIndex[i] - <span class="number">1</span>].rentPrice * useDays;</span><br><span class="line">			&#125;</span><br><span class="line">			input.close();</span><br><span class="line">			System.out.println(<span class="string">"\n--总共可搭乘："</span>+passengerSum+<span class="string">"人"</span>);</span><br><span class="line">			<span class="comment">//计算可搭乘货物量的代码类似，这里就略去</span></span><br><span class="line">			System.out.println(<span class="string">"--总共花费："</span>+moneySum+<span class="string">" CNY"</span>);</span><br><span class="line">			System.out.println(<span class="string">"*********租车结束，欢迎再次光临！*******"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"*********谢谢来访，欢迎再次光临！*******"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[LeetCode] - 两道3Sum题目]]></title>
      <url>http://yoursite.com/2017/01/31/%E3%80%90LeetCode%E3%80%91%20-%20%E4%B8%A4%E9%81%933Sum%E9%A2%98%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>一道实现起来比较简单的题，但是被细节坑了很久….</p>
<p>原题如下：</p>
<blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note: The solution set must not contain duplicate triplets.</p>
<p>For example, given array S = [-1, 0, 1, 2, -1, -4],</p>
<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]<br><a id="more"></a></p>
</blockquote>
<p>题目意思就是找出三数相加为0的数，组合成新的数组返回。<br>做leetcode第一题就是2sum（找出两数相加为0的数并返回索引），这题算是加强版吧。</p>
<p><strong>解题过程：</strong><br>The solution uses the sliding window/two pointers algorithm. Let us try to solve the simpler problem first:<br>Given a sorted array, find all pairs of elements a,b such that a+b=c, a given value</p>
<p>Now, suppose that we have found a solution ar[i],ar[j]. That is, ar[i]+ar[j]=c. If there is some other solution with ar[i’] (That is, ar[i’]+ar[j’]=c), we will have j’≤j. Using this observation the problem can be solved by the following function in O(N):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void findpairs(int ar[],int N,int c)</span><br><span class="line">&#123;</span><br><span class="line">  for(int i=0,j=N-1;i&lt;j;)</span><br><span class="line">  &#123;</span><br><span class="line">    //Move the j-pointer to the left till the sum &lt;=c</span><br><span class="line">    if(ar[i]+ar[j]&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">      j--;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ar[i]+ar[j]==c)printf(&quot;%d %d\n&quot;,ar[i],ar[j]);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if there are duplicate entries in the array, there could be duplicate entries in the output too. This can be easily taken care of by a simple modification. We ensure that we process the i-values corresponding to a given ar[i] only once:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void findpairs(int ar[],int N,int c)</span><br><span class="line">&#123;</span><br><span class="line">  for(int i=0,j=N-1;i&lt;j;)</span><br><span class="line">  &#123;</span><br><span class="line">    if(ar[i]+ar[j]&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">      j--;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ar[i]+ar[j]==c)printf(&quot;%d %d\n&quot;,ar[i],ar[j]);</span><br><span class="line">    //Increment i till ar[i] is different from current value</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;while((i&lt;j)&amp;&amp;(ar[i]==ar[i-1]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now to get back to the original problem. We will sort the array first to utilise the two pointers algorithm. Let us first fix the smallest element in the triplet ar[i]. Now we need to find other elements in the array such that their sum is -ar[i]. Using the same trick to avoid repetitions, here is the final solution:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findtriplets</span><span class="params">(<span class="keyword">int</span> ar[],<span class="keyword">int</span> N)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = [];</span><br><span class="line">  <span class="comment">//First sort the array since the method works only for sorted arrays</span></span><br><span class="line">  sort(ar,ar+N);</span><br><span class="line">  <span class="comment">//Loop over first element of triplet</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//Discard repetitions for first element</span></span><br><span class="line">    <span class="keyword">if</span>((i&gt;=<span class="number">0</span>)&amp;&amp;(ar[i]==ar[i<span class="number">-1</span>]))<span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//This loop is essentially the same as findpairs() above.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>,k=N<span class="number">-1</span>;j&lt;k;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(ar[i]+ar[j]+ar[k]&gt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(ar[i]+ar[j]+ar[k]==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         result.push([nums[i],nums[j],nums[k]]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;<span class="keyword">while</span>((j&lt;k)&amp;&amp;(ar[j]==ar[j<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sorting takes O(N log N) time whereas the repeated application of the two pointers algorithm takes O(N²) time.</p>
<hr>
<p>另一题是第一题的变体，题目叫‘3Sum Closest’。实现起来更简单，原题如下：</p>
<blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.<br>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp, sum, tsum;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">    <span class="keyword">var</span> sorted = nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; sorted.length; i++)&#123;</span><br><span class="line">       <span class="keyword">var</span> start = i+<span class="number">1</span>, end= sorted.length<span class="number">-1</span>;</span><br><span class="line">       <span class="comment">// 这里用到了二分法</span></span><br><span class="line">       <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            tsum = sorted[i] + sorted[start] + sorted[end];</span><br><span class="line">            temp = <span class="built_in">Math</span>.abs(tsum - target);</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; key)&#123;</span><br><span class="line">                key = temp;</span><br><span class="line">                sum = tsum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tsum &lt; target)&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  [LeetCode] - 不使用加减运算符，求两数之和]]></title>
      <url>http://yoursite.com/2017/01/15/%E3%80%90LeetCode%E3%80%91-%20%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E6%B1%82%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<p>今天刷leetCode看到一道题蛮有意思的，做个记录。</p>
<p>原题如下：</p>
<blockquote>
<p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br>Given a = 1 and b = 2, return 3.<br><a id="more"></a><br>题目意思很简单，如标题所述，要想不用加减号(普通运算符)求和，自然联想到位运算，关于位运算相关知识可参考：<a href="http://blog.csdn.net/21aspnet/article/details/7387373" target="_blank" rel="external">http://blog.csdn.net/21aspnet/article/details/7387373</a></p>
</blockquote>
<p>回顾一下二进制加法计算过程：在做某位加法时，单看这一位，若两数相同，则得出0；若不同，则得出1，这不就是位运算当中的异或^嘛！</p>
<p>知道了这个，怎么处理进位呢？接着看二进制加法，进位特点是：都是往高处（向左）进一位，且只有两个加数都是1时，才会产生进位，这不就是按位与&amp;嘛。将按位与得到的数字向左移动一位，把其当成一个新数字，用新数字与上一步逐位异或得到的数字相加，重复这个过程。实际上就是拆分了每一步进位过程，每一次循环即为一次进位，加到最后，肯定不产生进位了。 即当按位与的结果为0的时候，证明已经没有进位，循环终止，此时得到的sum即为两数的和。</p>
<p>举个栗子:<br>设有a = 3，b = 6。</p>
<p>a　　　　0011</p>
<p>b　　　　0110</p>
<p>不进位和(按位异或) 0101  = 5</p>
<p>进位（按位与）  0010  = 2</p>
<p><strong>因此 a + b就变成了5 + （2 &lt;&lt; 1）</strong></p>
<p>然后有</p>
<p>5　　　　0101</p>
<p>2&lt;&lt;1 　　0100</p>
<p>不进位和 0001  = 1</p>
<p>进位          0100  = 4</p>
<p><strong>因此 a + b就变成了1 + （4 &lt;&lt; 1）</strong></p>
<p>然后有</p>
<p>1　　　　0001</p>
<p>4&lt;&lt;1 　　1000</p>
<p>不进位和 1001  = 9</p>
<p>进位          0000  = 0</p>
<p><strong>当进位为0时，不进位和为9，即a + b和为9。</strong></p>
<p>实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;number&#125; a</span><br><span class="line"> * @param &#123;number&#125; b</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jinwei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        jinwei = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = sum;</span><br><span class="line">        b = jinwei;</span><br><span class="line">    &#125;<span class="keyword">while</span>(jinwei != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【js游戏】 之 「五子棋」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90js%E6%B8%B8%E6%88%8F%E3%80%91%E4%B9%8B%E3%80%8C%E4%BA%94%E5%AD%90%E6%A3%8B%E3%80%8D/</url>
      <content type="html"><![CDATA[<p>用js撸了几个小游戏，比如五子棋（人机对战），有空写个详细的实现过程，不过代码注释已经写得比较详细了，直接审查元素就能看到。</p>
<hr>
<p>这里直接上五子棋游戏传送门：<br><a href="http://www.kangkai.science/chess.html" target="_blank" rel="external">http://www.kangkai.science/chess.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「快速排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>快排简而言之就三步：</p>
<ol>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<a id="more"></a>
</li>
</ol>
<h3 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h3><ol>
<li>时间复杂度：O（nlogn）</li>
<li>空间复杂度：O（N）</li>
<li>排序性质：主要操作在源数据存储区进行，属于内部排序。不稳定排序。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里参照了阮一峰老师的JS 实现</p>
<p>定义一个quickSort函数，它的参数是一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，检查数组的元素个数，如果小于等于1，就返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) ;</span><br><span class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">　　<span class="keyword">var</span> left = [];</span><br><span class="line">　　<span class="keyword">var</span> right = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于基准的元素放入右边的子集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) ;</span><br><span class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">　　<span class="keyword">var</span> left = [];</span><br><span class="line">　　<span class="keyword">var</span> right = [];</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后，使用递归不断重复这个过程，就可以得到排序后的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">　　<span class="keyword">var</span> left = [];</span><br><span class="line">　　<span class="keyword">var</span> right = [];</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>C语言版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key; <span class="comment">//key即为基准</span></span><br><span class="line">    key = arr[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;high &amp;&amp; arr[high] &gt;= key)</span><br><span class="line">            high--;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        <span class="comment">// 注意是先赋值后移动</span></span><br><span class="line">            arr[low++] = arr[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt;high &amp;&amp; arr[low] &lt;= key)</span><br><span class="line">            low++;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">            arr[high--] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (start&lt;end)&#123;</span><br><span class="line">        pos = partition(arr, start, end);</span><br><span class="line">        quick_sort(arr,start,pos<span class="number">-1</span>);</span><br><span class="line">        quick_sort(arr,pos+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> arr[N]=&#123;<span class="number">32</span>,<span class="number">12</span>,<span class="number">7</span>, <span class="number">78</span>, <span class="number">23</span>,<span class="number">45</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序前 \n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,arr[i]);</span><br><span class="line">    quick_sort(arr,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n 排序后 \n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「冒泡排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>冒泡重复地走访要排序的数列，一次比较最底下两个元素（即数列最前面两个元素），如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</p>
<p>每一轮交换都换产生余下数组最大的数，并冒到顶部。<br><a id="more"></a></p>
<h3 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h3><ol>
<li>时间复杂度：O(N^2)，进行N-1轮操作，每次进行n-1次交换</li>
<li>空间复杂度：O(N)</li>
<li>排序性质：内部排序，稳定排序</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>先列出一种效率较低的方法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">int</span> i,j,mid;</span><br><span class="line">      <span class="keyword">int</span> length = <span class="number">10</span>;</span><br><span class="line">      <span class="comment">//开始外圈循环</span></span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">          <span class="comment">//外圈循环到i时，说明该数组的后i-1个数已经排好序并且是最大值</span></span><br><span class="line">          <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">9</span>-i;j++) </span><br><span class="line">          &#123;</span><br><span class="line">               <span class="keyword">if</span>(a[j]&gt;=a[j+<span class="number">1</span>])</span><br><span class="line">               &#123;</span><br><span class="line">                    mid = a[j];</span><br><span class="line">                    a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                    a[j+<span class="number">1</span>] = mid;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d   "</span>,a[i]);</span><br><span class="line">      system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个冒泡排序算法中有一个缺陷，如果数组是 2 1 3 4 5 6 ，那么在第一次外圈结束后，该数组就已经完成排序，但是程序还是会继续循环下去，做很多无用的比较，但是根本不会出现数的位置的交换。++所以我们需要考虑一下冒泡排序的结束条件++。</p>
<p>下面给出一个定义：如果冒泡排序在一次外圈的内圈循环中没有出现数的位置的交换，那么该数组排序完成，不需要向下进行。解释一下这个定义，内圈的循环是从0~length-i-1的，不出现交换说明在这个范围内后一个数都大于前一个数，而在length-i-1至lenth的范围中，本来就是符合条件的，所以定义成立。<br>所以我们添加一个flag标志，观察在每次外圈时是否出现数值的交换。<br>下面给出改进算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">int</span> i,j,mid;</span><br><span class="line">      <span class="keyword">int</span> length = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> flag = <span class="number">1</span>;   <span class="comment">//标识符</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span> &amp;&amp; flag;i++)   <span class="comment">//注意判定条件</span></span><br><span class="line">          <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">9</span>-i;j++)</span><br><span class="line">          &#123;</span><br><span class="line">               flag=<span class="number">0</span>;        <span class="comment">//每次外圈时初始化</span></span><br><span class="line">               <span class="keyword">if</span>(a[j] &gt;= a[j+<span class="number">1</span>])</span><br><span class="line">               &#123;</span><br><span class="line">                    mid = a[j];</span><br><span class="line">                    a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                    a[j+<span class="number">1</span>] = mid;</span><br><span class="line">                    flag=<span class="number">1</span>;      <span class="comment">//如果有交换，那么可以进入下一圈循环</span></span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d   "</span>,a[i]);</span><br><span class="line">      system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「归并排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。不断将已有序的子序列合并，最后得到一个统一的有序序列。</p>
<p>归并操作(从小到大）的工作原理如下：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并将该指针移动到下一位置（另一指向较大元素的指针位置不变）。</li>
<li>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾<a id="more"></a>
<h3 id="相关性质总结"><a href="#相关性质总结" class="headerlink" title="相关性质总结"></a>相关性质总结</h3></li>
<li>时间复杂度：O(n log n) ；</li>
<li>空间复杂度：O（N）；</li>
<li>排序性质：稳定</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> sourceArr[],<span class="keyword">int</span> tempArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> midIndex, <span class="keyword">int</span> endIndex)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="comment">//i 和 j分别指向两个有序数组的起始位置;k是排序后新数组的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = startIndex, j=midIndex+<span class="number">1</span>, k = startIndex;</span><br><span class="line">    <span class="keyword">while</span>(i!=midIndex+<span class="number">1</span> &amp;&amp; j!=endIndex+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">        <span class="comment">//tempArr为二路归并后的新数组</span></span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩下所有的元素都移到tempArr数组</span></span><br><span class="line">    <span class="keyword">while</span>(i != midIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j != endIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> sourceArr[], <span class="keyword">int</span> tempArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        midIndex = (startIndex + endIndex) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">        <span class="comment">//最后将两个有序数组合并</span></span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i, b[<span class="number">8</span>];</span><br><span class="line">    MergeSort(a, b, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[  【排序算法】之「插入排序」]]></title>
      <url>http://yoursite.com/2016/12/10/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%E4%B9%8B%E3%80%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%8D/</url>
      <content type="html"><![CDATA[<p><strong>前言：</strong>在【排序算法】板块中，我将纳入几种主流的排序算法学习笔记，代码以C为主，可能还会涉及我较熟悉的JavaScript</p>
<p><em>内容很基础，作为今后快速查阅的资料</em></p>
<hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>插入排序是排序算法的一种，它不改变原有的序列（数组），而是创建一个新的序列，在新序列上进行操作。</p>
<p>基本思想是，将元素逐个添加到已经排序好的数组中去，同时要求，插入的元素必须在正确的位置，这样原来排序好的数组是仍然有序的。第i轮排序时，在前i个元素的子数组中插入第i+1个元素。直到所有元素都加入排序好数组。<strong>类似于打扑克牌的抓拍过程，每次抓一张新牌都将其插入到手里已经排好序的牌当中。</strong><br><a id="more"></a></p>
<h3 id="相关性质总结"><a href="#相关性质总结" class="headerlink" title="相关性质总结"></a>相关性质总结</h3><ol>
<li>时间复杂度：O(N平方),无论何种情况，要插入N个数首先必然要进行N轮操作，最坏情况下再交换N次，即N*N;</li>
<li>空间复杂度：O（N），即存储N个数字的空间</li>
<li>排序性质：插入排序是一种稳定的排序算法，不会改变原有序列中相同数字的顺序；均在内存中进行，为内部排序。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//插入排序实现,这里按从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span><span class="comment">//n为数组a的元素个数</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//进行N-1轮插入过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先找到元素a[i]需要插入的位置</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( (a[j]&lt;a[i]) &amp;&amp; (j&lt;i) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里a[j]实际为新构造的排序后的数组，j即为插入位置</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将元素插入到正确的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i != j)  <span class="comment">//如果i==j，说明a[i]刚好在正确的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &gt; j; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k] = a[k<span class="number">-1</span>];<span class="comment">//将插入位置以后的数都后移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = temp;<span class="comment">//将数字插入位置j</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[N] = &#123;<span class="number">89</span>, <span class="number">38</span>, <span class="number">11</span>, <span class="number">78</span>, <span class="number">96</span>, <span class="number">44</span>, <span class="number">19</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    insert_sort(num, N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, num[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客上线小记]]></title>
      <url>http://yoursite.com/2016/05/22/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><del>写在前面的屁话</del></p>
<pre><code>好久没有碰工程项目啦！自从大二在工作室接外包做了几个项目之后，除了课程相关的代码，
就再也没有实际的写过东西了，这段时间趁着导师内边事情不多，把自己的博客搭起来，也算练练手吧。
</code></pre><h3 id="为什么要搭建个人博客"><a href="#为什么要搭建个人博客" class="headerlink" title="为什么要搭建个人博客"></a>为什么要搭建个人博客</h3><ul>
<li><p><strong>记录</strong>：自从高中毕业之后，很少用心写作了（说的好像高中作文也是用心写的一样）。决心利用博客重新开始写作，主要用来记录自己的技术成长路线，偶尔也会用来表达生活感悟。</p>
</li>
<li><p><strong>分享</strong>：过去我看过很多的个人博客（几乎是程序猿标配了），却一直没有抽时间搭建属于自己的博客。现在觉得还是得把它建起来，主要为自己记录，最好也能为他人做微不足道的分享。其实一直有想法找个地方写写东西，新浪博客、CSDN、微信公众号都有尝试，还有幸作为知乎专栏内测用户，但是都没有坚持下去，希望这里能够记录更多的内容吧。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="怎么搭建个人博客"><a href="#怎么搭建个人博客" class="headerlink" title="怎么搭建个人博客"></a>怎么搭建个人博客</h3><p>阮一峰老师说过，博客的搭建会经历三个阶段:</p>
<blockquote>
<p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</p>
<p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p>
<p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<p>  这里我选择了第二种方式，但是抱着急功近利的心态，连最初计划的后端Thinkphp + 前端bootstrap框架的方法都放弃了，直接用了github的开源框架hexo…（ 羞耻脸</p>
<p>  全站自己写的东西不多，用了无数轮子，主要功夫都花在配环境和「移花接木」上了。</p>
<hr>
<p>  <em>2016.05.22晚</em></p>
<p> 买了自己的独立域名，算是正式上线的开始吧，<br> 原本是想买最直接的”www.kangkai.com”,即姓名全拼+com后缀，无奈也不出意外地被注册了，连cn,org等传统顶级域名都被注册了….</p>
<p> 只好另辟蹊径，发现了.science后缀觉得挺有big的。。就果断买了下来（到2018年都是我的哈哈哈）</p>
<p>  之前建设过程中迭代过几个版本，这里就不一一详细记录了，今后有功能上的变化都会把过程和技术难点以博客形式记录。上一版中增加了文章末尾的微信打赏二维码和RSS订阅功能，优化了评论框（多说接口）的性能和UI设计，不存在技术上问题。</p>
<p>  差不多了，我去看电影了，bye~</p>
<p>  <strong>喜欢我的博客或者发现bug欢迎留言！</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dijkstra's algorithm]]></title>
      <url>http://yoursite.com/2016/05/19/Dijkstra-s-algorithm/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Dijkstra’s algorithm</strong></p>
<h2 id="Dijkstra’s-algorithm-is-an-algorithm-for-finding-the-shortest-paths-between-nodes-in-a-graph-which-may-represent-for-example-road-networks-It-was-conceived-by-computer-scientist-Edsger-W-Dijkstra-in-1956-and-published-three-years-later"><a href="#Dijkstra’s-algorithm-is-an-algorithm-for-finding-the-shortest-paths-between-nodes-in-a-graph-which-may-represent-for-example-road-networks-It-was-conceived-by-computer-scientist-Edsger-W-Dijkstra-in-1956-and-published-three-years-later" class="headerlink" title="Dijkstra’s algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later."></a>Dijkstra’s algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</h2><p>戴克斯特拉算法（英语：Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。<br><a id="more"></a></p>
<pre><code>   function Dijkstra(G, w, s)
      for each vertex v in V[G]                        // 初始化
            d[v] := infinity                                 // 將各點的已知最短距離先設成無窮大
            previous[v] := undefined                         // 各点的已知最短路径上的前趋都未知
     d[s] := 0                                              // 因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0
      S := empty set
      Q := set of all vertices
      while Q is not an empty set                      // Dijkstra演算法主體
            u := Extract_Min(Q)
10           S.append(u)
11           for each edge outgoing from u as (u,v)
12                  if d[v] &gt; d[u] + w(u,v)             // 拓展边（u,v）。w(u,v)为从u到v的路径长度。
13                        d[v] := d[u] + w(u,v)               // 更新路径长度到更小的那个和值。
14                        previous[v] := u                    // 紀錄前趨頂點
</code></pre><p>该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t 的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。</p>
<p>最初的戴克斯特拉算法不采用最小优先级队列，时间复杂度是O(|V|^2)(其中|V|为图的顶点个数)。通过斐波那契堆实现的迪科斯彻算法时间复杂度是O(|E|+|V|\log|V|) (其中|E|是边数) （Fredman &amp; Tarjan 1984）。对于不含负权的有向图，这是目前已知的最快的单源最短路径算法。</p>
<p>如果我们只对在 s 和 t 之间查找一条最短路径的话，我们可以在第9行添加条件如果满足 u = t 的话终止程序。</p>
<p>通过推导可知，为了记录最佳路径的轨迹，我们只需记录该路径上每个点的前趋，即可通过迭代来回溯出 s 到 t 的最短路径（当然，使用后继节点来存储亦可。但那需要修改代码）：</p>
<pre><code>1 s := empty sequence 
2 u := t
3 while defined u                                        
4       insert u to the beginning of S
5       u := previous[u]      //previous数组即为上文中的p
</code></pre>]]></content>
    </entry>
    
  
  
</search>
